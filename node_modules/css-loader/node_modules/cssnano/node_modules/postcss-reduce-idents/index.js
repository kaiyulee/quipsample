'use strict';

var postcss = require('postcss');
<<<<<<< HEAD
var parser = require('postcss-value-parser');
var encode = require('./lib/encode');
=======
var reduce = require('reduce-function-call');
var encode = require('./lib/encode');
var list = postcss.list;

function eachValue (value, callback) {
    return list.space(value).map(function (val) {
        return list.comma(val).map(callback).join();
    }).join(' ');
}
>>>>>>> 14e45b6ab8a1ca954f5516d80087167e98f6b292

function transformAtRule (css, atRuleRegex, propRegex) {
    var cache = {};
    var ruleCache = [];
    // Encode at rule names and cache the result
<<<<<<< HEAD
    css.walkAtRules(atRuleRegex, function (rule) {
=======
    css.eachAtRule(atRuleRegex, function (rule) {
>>>>>>> 14e45b6ab8a1ca954f5516d80087167e98f6b292
        if (!cache[rule.params]) {
            cache[rule.params] = {
                ident: encode(Object.keys(cache).length),
                count: 0
            };
        }
        rule.params = cache[rule.params].ident;
        ruleCache.push(rule);
    });
    // Iterate each property and change their names
<<<<<<< HEAD
    css.walkDecls(propRegex, function (decl) {
        decl.value = parser(decl.value).walk(function (node) {
            if (node.type === 'word' && node.value in cache) {
                cache[node.value].count++;
                node.value = cache[node.value].ident;
            }
            if (node.type === 'space') {
                node.value = ' ';
            }
            if (node.type === 'div') {
                node.before = '';
                node.after = '';
            }
        }).toString();
=======
    css.eachDecl(propRegex, function (decl) {
        decl.value = eachValue(decl.value, function (value) {
            if (value in cache) {
                cache[value].count++;
                return cache[value].ident;
            }
            return value;
        });
>>>>>>> 14e45b6ab8a1ca954f5516d80087167e98f6b292
    });
    // Ensure that at rules with no references to them are left unchanged
    ruleCache.forEach(function (rule) {
        Object.keys(cache).forEach(function (key) {
            var k = cache[key];
            if (k.ident === rule.params && !k.count) {
                rule.params = key;
            }
        });
    });
}

module.exports = postcss.plugin('postcss-reduce-idents', function () {
    return function (css) {
        var cache = {};
        var declCache = [];
<<<<<<< HEAD
        css.walkDecls(/counter-(reset|increment)/, function (decl) {
            decl.value = parser(decl.value).walk(function (node) {
                if (node.type === 'word' && !/^-?\d*$/.test(node.value)) {
                    if (!cache[node.value]) {
                        cache[node.value] = {
=======
        css.eachDecl(/counter-(reset|increment)/, function (decl) {
            decl.value = eachValue(decl.value, function (value) {
                if (!/^-?\d*$/.test(value)) {
                    if (!cache[value]) {
                        cache[value] = {
>>>>>>> 14e45b6ab8a1ca954f5516d80087167e98f6b292
                            ident: encode(Object.keys(cache).length),
                            count: 0
                        };
                    }
<<<<<<< HEAD
                    node.value = cache[node.value].ident;
                }
                if (node.type === 'space') {
                    node.value = ' ';
                }
            });
            declCache.push(decl);
        });
        css.walkDecls('content', function (decl) {
            decl.value = parser(decl.value).walk(function (node) {
                if (node.type === 'function') {
                    if (node.value === 'counter' || node.value === 'counters') {
                        node.nodes.forEach(function (node) {
                            if (node.type === 'word' && node.value in cache) {
                                cache[node.value].count++;
                                node.value = cache[node.value].ident;
                            }
                            if (node.type === 'div') {
                                node.before = '';
                                node.after = '';
                            }
                        });
                    }
                    return false;
                }
                if (node.type === 'space') {
                    node.value = ' ';
                }
            }).toString();
        });
        declCache.forEach(function (decl) {
            decl.value = decl.value.walk(function (node) {
                if (node.type === 'word' && !/^-?\d*$/.test(node.value)) {
                    Object.keys(cache).forEach(function (key) {
                        var k = cache[key];
                        if (k.ident === node.value && !k.count) {
                            node.value = key;
                        }
                    });
                }
            }).toString();
=======
                    return cache[value].ident;
                }
                return value;
            });
            declCache.push(decl);
        });
        css.eachDecl('content', function (decl) {
            decl.value = eachValue(decl.value, function (value) {
                return reduce(value, /(counters?)\(/, function (body, fn) {
                    var counters = list.comma(body).map(function (counter) {
                        if (counter in cache) {
                            cache[counter].count++;
                            return cache[counter].ident;
                        }
                        return counter;
                    }).join(',');
                    return fn + '(' + counters + ')';
                });
            });
        });
        declCache.forEach(function (decl) {
            decl.value = eachValue(decl.value, function (value) {
                if (!/^-?\d*$/.test(value)) {
                    Object.keys(cache).forEach(function (key) {
                        var k = cache[key];
                        if (k.ident === value && !k.count) {
                            value = key;
                        }
                    });
                    return value;
                }
                return value;
            });
>>>>>>> 14e45b6ab8a1ca954f5516d80087167e98f6b292
        });
        // Transform @keyframes, @counter-style
        transformAtRule(css, /keyframes/, /animation/);
        transformAtRule(css, 'counter-style', /(list-style|system)/);
    };
});
